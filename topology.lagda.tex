\begin{code}
open import Relation.Nullary.Negation
open import Level
open import Function
open import Data.Bool
open import Data.List
open import Data.Product
open import Data.List.Relation.Unary.All using (All)
open import Relation.Binary.HeterogeneousEquality
open import Data.Sum
open import Data.Empty.Polymorphic
open import Data.Unit.Polymorphic
open import Relation.Unary hiding (⋂)

-- | This paper uses @NSet@ to represent sets.  Any value @n@ of type @NSet A@
-- represents the set \(t\) such that for all values @e@ of type @A@, a value of
-- type @n e@ exists if and only if @e@ is an element of \(t\).
--
-- The author chose the name "NSet" because "Set" was already taken.  The "N"
-- is arbitrary but can be interpreted as meaning "new" or something by
-- readers who need justifications for even the most arbitrary choices.
-- Etymology only goes so far.
NSet : {a : Level} -> Set a -> Set (Level.suc a)
NSet {a} A = Pred A a

⋂ : {a : Level} -> {A : Set a} -> List (NSet A) -> NSet A
⋂ [] _ = ⊥
⋂ (x ∷ []) = x
⋂ (x ∷ xs) = x ∩ ⋂ xs

module SubsetProperties {a : Level} {A : Set a} (s1 : NSet A) where
  self-is-subset : s1 ⊆ s1
  self-is-subset x = x

  null-set-is-subset : (\ _ -> ⊥ {a}) ⊆ s1
  null-set-is-subset ()

  big-intersection-of-subsets-is-subset :
    (sl : List (NSet A)) ->
    All (λ e -> e ⊆ s1) sl ->
    ⋂ sl ⊆ s1
  big-intersection-of-subsets-is-subset = {!!}

  union-is-subset :
    (s2 s3 : NSet A) ->
    s2 ⊆ s1 ->
    s3 ⊆ s1 ->
    (s2 ∪ s3) ⊆ s1
  union-is-subset = {!!}

-- | @P S@ is the power set of @S@.  Equivalently, @P S@ is the set of all subsets of @S@.
--
-- One can easily say that a value \(e\) is an element of the power set of \(S\) if and only if \(e\) is a subset of \(S\).  Accordingly, @P@ is pretty simple.
P : {a : Level} -> {A : Set a} -> NSet A -> NSet (NSet A)
P {a} {A} s e = e ⊆ s × ⊤

module PowerSetProperties {a : Level} {A : Set a} (N : NSet A) where
  element-only-if-subset : {s : NSet A} -> s ∈ P N -> s ⊆ N
  element-only-if-subset = proj₁

  contains-union : (s1 s2 : NSet A) -> s1 ∈ P N -> s2 ∈ P N -> (s1 ∪ s2) ∈ P N
  contains-union s1 s2 s1elem s2elem =
    SubsetProperties.union-is-subset N s1 s2 s1sub s2sub , tt
    where
      s1sub = element-only-if-subset s1elem
      s2sub = element-only-if-subset s2elem

  contains-all-subsets : {s : NSet A} -> s ⊆ N -> s ∈ P N
  contains-all-subsets subset = subset , tt

  contains-intersection : (s : List (NSet A)) ->
                          All (\ e -> e ∈ P N) s ->
                          ⋂ s ∈ P N
  contains-intersection s = contains-all-subsets ∘ bigint-is-subset N s ∘ elements-to-subsets
    where
    bigint-is-subset = SubsetProperties.big-intersection-of-subsets-is-subset
    elements-to-subsets = Data.List.Relation.Unary.All.map element-only-if-subset

  contains-self : N ∈ P N
  contains-self = contains-all-subsets (SubsetProperties.self-is-subset N)

  contains-null-set : (\ _ -> ⊥ {a}) ∈ P N
  contains-null-set = contains-all-subsets (SubsetProperties.null-set-is-subset N)

-- | Any value @t@ of type @Topology N@ is a topology on @N@.
-- @Topology.collection N@ is @t@'s collection, and the other fields indicate
-- that @t@ really is a topology.
record Topology {a : Level}
                {A : Set a}
                (N : NSet A) : Set (Level.suc (Level.suc a)) where
  field
    collection : NSet (NSet A)
    hasEmptySet : (\ _ -> ⊥) ∈ collection
    hasN : N ∈ collection
    hasUnion : (s1 s2 : NSet A) ->
               s1 ∈ collection ->
               s2 ∈ collection ->
               (s1 ∪ s2) ∈ collection
    hasIntersection : (s : List (NSet A)) ->
                      All (\ e -> e ∈ collection) s ->
                      ⋂ s ∈ collection

-- | @DiscreteTopology@ values represent discrete topologies.
record DiscreteTopology {a : Level}
                        {A : Set a}
                        (N : NSet A) : Set (Level.suc (Level.suc a)) where
  field
    topology : Topology N
    isDiscrete : P N ⊆ Topology.collection topology ×
                 Topology.collection topology ⊆ P N

-- | @discreteTopology N@ is a discrete topology on @N@.
discreteTopology : {a : Level} -> {A : Set a} -> (N : NSet A) -> DiscreteTopology N
discreteTopology N = record
  {topology = record
     {collection = P N
     ;hasN = PowerSetProperties.contains-self N
     ;hasEmptySet = PowerSetProperties.contains-null-set N
     ;hasUnion = PowerSetProperties.contains-union N
     ;hasIntersection = PowerSetProperties.contains-intersection N
     }
  ;isDiscrete = (\ e -> e , e) (SubsetProperties.self-is-subset (P N))}

-- | @IndiscreteTopology@ values represent indiscrete topologies.
-- Indicating that the empty set and @N@ are elements of
-- @Topology.collection (IndiscreteTopology.topology i)@ would be redundant;
-- @Topology@ records already have fields which make these guarantees.
record IndiscreteTopology {a : Level}
                          {A : Set a}
                          (N : NSet A) : Set (Level.suc (Level.suc a)) where
  field
    topology : Topology N
    isIndiscrete : (n : NSet A) ->
                   n ≇ N ->
                   n ≇ (\ (_ : A) -> ⊥ {a})
                   -> ¬ Topology.collection topology n

-- | @indiscreteTopology n@ is an indiscrete topology on @N@.
indiscreteTopology : {a : Level} ->
                     {A : Set a} ->
                     (N : NSet A) ->
                     IndiscreteTopology N
indiscreteTopology {a} {A} N = record
  {topology = record
     {collection = f
     ;hasN = inj₁ refl
      -- Agda 2.6.4.3 with standard-library-2.1 fails to understand that refl is
      -- appropriate for the hasEmptySet definition.
     ;hasEmptySet = inj₂ {!!}
     ;hasUnion = {!!}
     ;hasIntersection = {!!}
     }
   -- The combination of Agda 2.6.4.3 and the standard library has similar
   -- problems with the following definition:
  ;isIndiscrete = \ n N1 N2 -> neither-implies-neither N1 {!!}}
  where
  f : NSet (NSet A)
  f x = x ≅ N ⊎ x ≅ (λ (_ : NSet A) → ⊥ {a})
  neither-implies-neither :
    {a b : Level} ->
    {A : Set a} ->
    {B : Set b} ->
    ¬ A ->
    ¬ B ->
    ¬ (A ⊎ B)
  neither-implies-neither = {!!}
  
_isFinerThan_ : {a : Level} ->
                {A : Set a} ->
                {N : NSet A} ->
                Topology N ->
                Topology N ->
                Set _
t1 isFinerThan t2 = Topology.collection t2 ⊆ Topology.collection t1

record Basis {a : Level}
             {A : Set a}
             (N : NSet A) : Set (Level.suc Level.zero Level.⊔ Level.suc (Level.suc a)) where
  field
   elements : NSet (NSet A)
   allContainedByBasisElements :
     (e : A) ->
     e ∈ N ->
     Σ (NSet A) (\ n -> e ∈ n × n ∈ elements)
   multiContainmentImpliesProperSubset :
     (e : A) ->
     e ∈ N ->
     (n1 n2 : NSet A) ->
     e ∈ (n1 ∩ n2) ->
     Σ (NSet A) (\ n3 -> n3 ⊂ (n1 ∩ n2) × n3 ∈ elements)
\end{code}
